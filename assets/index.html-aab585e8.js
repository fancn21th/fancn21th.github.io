import{_ as r,r as n,o as u,c as _,a as l,b as e,d as o,w as t,e as d}from"./app-e3dbf12f.js";const h={},p=l("h1",{id:"概述",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#概述","aria-hidden":"true"},"#"),e(" 概述")],-1),f=l("code",null,"惯性思维",-1),E=l("code",null,"Layering 分层",-1),m={href:"https://dsmorse.github.io/gridster.js/",target:"_blank",rel:"noopener noreferrer"},x=l("code",null,"布局系统",-1),B=l("code",null,"进出场动画",-1),b=l("p",null,[e("很讨厌不是吗 "),l("code",null,"惯性思维"),e(" 是大脑最舒适的思维方式, 它完全凭着记忆和下意识的去得出结论. 或者说是经验学. 甚至有的时候我们把这个叫做 "),l("code",null,"灵感"),e(".")],-1),P=d('<h2 id="自研框架" tabindex="-1"><a class="header-anchor" href="#自研框架" aria-hidden="true">#</a> 自研框架</h2><p>为什么要自研框架 ? 成本可以控制吗 ? 交付能按时吗 ? 有没有风险 ?</p><p>选择 技术方案 有成熟的方法论, 常见考虑因素包括但不限于:</p><ul><li><p>客户需求</p><ul><li><p>功能需求</p></li><li><p><a href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82">非功能需求</a></p><p>用户体验, 兼容性, 合规性, 性能, 安全性 ...</p></li></ul></li><li><p>成本</p><ul><li>成熟度 受欢迎的程度</li><li>学习曲线</li><li>可伸缩 可扩展 可维护性</li><li>开发文档 与 开发社区</li></ul></li></ul>',4),V=l("code",null,"经验学",-1),g=l("a",{href:"#%E9%9D%9E%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"},"非功能需求",-1),k=l("h2",{id:"非功能需求",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#非功能需求","aria-hidden":"true"},"#"),e(" 非功能需求")],-1),A=l("p",null,"Vue3 与 其它 技术栈选择",-1),C=l("code",null,"需求规格说明书",-1),I=d("<li><p>局域网</p><ul><li>在内网运行不能访问外部网络</li><li>这个对地图组件的选择有很大的影响</li></ul></li><li><p>兼容老浏览器</p><ul><li>这个对 技术栈选择 有影响</li></ul></li><li><p>高度定制化 (客户带着设计师完成需求分析和原型设计)</p><ul><li>这个决定了 第三方 技术方案 是否可行</li></ul></li>",3),D=l("h2",{id:"设计维度",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#设计维度","aria-hidden":"true"},"#"),e(" 设计维度")],-1),N=d('<p>先从最重要的开始:</p><ul><li>路由</li><li>分层</li><li>布局系统</li><li>地图</li><li>信息卡片</li><li>图表 Charts</li></ul><p>先考虑这么多, 足够了, 这些模块即是独立的, 又是顺序相关的, 当他们要组合在一起的时候, 后面的元素必须建立在前面的元素之上.</p><h2 id="技术细节" tabindex="-1"><a class="header-anchor" href="#技术细节" aria-hidden="true">#</a> 技术细节</h2><p>技术细节一开始并不重要.</p><p>可能你无法相信, 项目开始的时候, 这个项目要用的每个技术栈, 我几乎都没有 <code>用过</code>. 但是我却对他们又非常 &quot;熟悉&quot;.</p><p>是的从 <code>业务</code> 角度 也就是目的 来说, 我很熟悉我要选择的技术栈. 从 <code>技术</code> 角度来说 我不记得 这些技术栈的 <code>API</code> 细节. 这就是我之前提到的 <code>反转</code>. 这反而能让我始终坚持 规范化中的原则.</p><p>随着项目的推进, 每个技术栈的 <code>API</code> 文档 从挑着看几页 演进到 几乎都被翻了个遍, 为了贯彻 <code>业务目标</code>, 每个技术栈的主要 <code>API</code> 甚至是 <code>隐藏技能</code> 都会被用到.</p><p>这不是巧合, 恰恰说明 技术栈就是对 <code>业务目标</code> 实现细节 的 最合理抽象.</p>',9);function v(L,T){const a=n("ExternalLinkIcon"),i=n("Term"),s=n("BestPractice"),c=n("Product");return u(),_("div",null,[p,l("p",null,[e("当看到大屏的设计稿, 想到的第一件事情是什么? 没错, 大脑 "),f,e(" 开始活动了. 我想到的是 "),E,e(" 和 "),l("a",m,[e("gridster"),o(a)]),e(),x,e(" 以及 "),B,e(".")]),l("p",null,[e("当然 我不会在这里展开 为什么我先想到的是这些, 这不符合我们的主题 "),o(i,null,{default:t(()=>[e("规范化")]),_:1}),e(".")]),b,l("p",null,[e("但是 "),o(i,null,{default:t(()=>[e("规范化")]),_:1}),e(" 可以说是截然不同的思维方式.")]),P,l("p",null,[e("这里不长篇大论, 无非还是 "),V,e(". 基于 "),g,e(" 自研框架是最佳选择. 当然花一点时间 做一个 "),o(s,null,{default:t(()=>[e("技术探针")]),_:1}),e(" 也是必要的.")]),k,l("ul",null,[l("li",null,[A,l("p",null,[e("用 "),o(c,null,{default:t(()=>[e("Vue")]),_:1}),e(" 作为技术栈往往都写在 "),C,e(" 里面. 甚至 图表组件库也要求使用 "),o(c,null,{default:t(()=>[e("Echarts")]),_:1}),e(".")]),l("p",null,[e("既然是 "),o(i,null,{default:t(()=>[e("业务需求")]),_:1}),e(", 照办.")])]),I]),D,l("p",null,[e("从头来过, 从 "),o(i,null,{default:t(()=>[e("业务需求")]),_:1}),e(" 出发, 设计稿里面的各种设计元素 我们怎么合理的 组织起来, 分而治之, 一个个的去实现它.")]),N])}const w=r(h,[["render",v],["__file","index.html.vue"]]);export{w as default};
