import{_ as r,r as a,o as s,c,a as e,b as n,d as o,e as d}from"./app-e3dbf12f.js";const i={},h=e("h1",{id:"设计模式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#设计模式","aria-hidden":"true"},"#"),n(" 设计模式")],-1),l={class:"custom-container tip"},_=e("p",{class:"custom-container-title"},"提示",-1),p={href:"https://refactoringguru.cn/design-patterns",target:"_blank",rel:"noopener noreferrer"},u=e("p",null,"上文出处 讲的是最经典的一些设计模式, 它们 常常和 后端研发 联系到一起. 但是本文着重讲的是 前端设计模式.",-1),f=e("p",null,"当然 前后端设计模式有的是相同的. 或者说是相通的.",-1),m=d('<h2 id="solid-原则" tabindex="-1"><a class="header-anchor" href="#solid-原则" aria-hidden="true">#</a> SOLID 原则</h2><h3 id="依赖倒置" tabindex="-1"><a class="header-anchor" href="#依赖倒置" aria-hidden="true">#</a> 依赖倒置</h3><p>Dependency Inversion Principle</p><h2 id="单一数据源" tabindex="-1"><a class="header-anchor" href="#单一数据源" aria-hidden="true">#</a> 单一数据源</h2>',4),x={href:"https://redux.js.org/understanding/thinking-in-redux/three-principles#single-source-of-truth",target:"_blank",rel:"noopener noreferrer"},b={href:"https://x.com/dan_abramov?s=20",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"单一数据源是所有状态设计的 核心与基础思想. 也就是每当你声明一个 状态. 响应式的也好, 普通的也好. 需要考虑它的来源是哪里, 来源是不是唯一的, 统一的, 一致的.",-1),k=e("h2",{id:"compound-component",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#compound-component","aria-hidden":"true"},"#"),n(" Compound Component")],-1),v=e("p",null,"我没有翻译这个模式的名字, 以免误解, 事实上这是一个标准的 前端设计模式 横跨 React 和 Vue.",-1);function V(I,N){const t=a("ExternalLinkIcon");return s(),c("div",null,[h,e("div",l,[_,e("p",null,[e("a",p,[n("设计模式"),o(t)]),n(" 是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题 ...")]),u,f]),m,e("p",null,[n("我第一次了解 "),e("a",x,[n("单一数据源"),o(t)]),n(" 是来自 "),e("a",b,[n("Dan Abramov"),o(t)]),n(", 其实它是一个非常大的概念. 或者换句话我在这里只是取其基本设计思想.")]),g,k,v])}const C=r(i,[["render",V],["__file","index.html.vue"]]);export{C as default};
